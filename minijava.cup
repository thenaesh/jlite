/* Minijava Grammar */

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

import java.io.*;

parser code {:
  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
  }
  public static void main(String[] args) throws Exception {
      // initialize the symbol factory
      ComplexSymbolFactory csf = new ComplexSymbolFactory();
      // create a buffering scanner wrapper
      ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(args[0])),csf));
      // start parsing
      Parser p = new Parser(lexer,csf);
      System.out.println(p.parse().value.toString());
  }
:};

// terminals
terminal CLASS, WHILE, READLN, PRINTLN, IF, ELSE, THIS, NEW, NULL;
terminal Integer INTCONST;
terminal Boolean BOOLCONST;
terminal String STRING_LITERAL;
terminal MAINFUNC;
terminal PLUS, MINUS, TIMES, DIV, UMINUS;
terminal LT, GT, GEQ, LEQ, EQ, NEQ;
terminal OR, AND;
terminal LPAREN, RPAREN, LBLOCK, RBLOCK;
terminal COMMA, DOT, ENDSTMT;
terminal RETURN;
terminal String IDNAME, CLASSNAME;

// non-terminals
non terminal ProgramAST program;
non terminal ClassAST mainclass;
non terminal FuncDeclAST mainfunction;
non terminal ListAST<ClassAST> classes;
non terminal Pair<ListAST<VarDeclAST>, ListAST<FuncDeclAST>> varsmethods, vars;
non terminal ListAST<FuncDeclAST> methods;
non terminal ListAST<VarDeclAST> params, paramlist, nonemptyparamlist, restparamlist;
non terminal BlockAST block;
non terminal Pair<ListAST<VarDeclAST>, ListAST<StmtAST>> blockvars;
non terminal ListAST<StmtAST> stmts, reststmts;
non terminal AST atom;
non terminal AST exp, bexp, aexp;
non terminal ConstAST<Integer> intconst;
non terminal ConstAST<Boolean> boolconst;
non terminal ConstAST<String> stringliteral;

// precedence
precedence left CLASS, IDNAME, CLASSNAME;
precedence left LPAREN, RPAREN;
precedence left PLUS, MINUS, TIMES, DIV;
precedence left UMINUS;

// program handling
program ::= mainclass:mc classes:cs {:  RESULT = new ProgramAST(mc, cs); :};

// main class handling
mainclass ::= CLASS CLASSNAME:c LBLOCK mainfunction:f RBLOCK {: RESULT = new ClassAST(c, new ListAST<VarDeclAST>(), new ListAST(f)); :} ;
mainfunction ::= MAINFUNC params:ps block:b {: RESULT = new FuncDeclAST("Void", "main", ps, b); :};

// general class handling
classes ::= {: RESULT = new ListAST<ClassAST>(); :}
  | CLASS CLASSNAME:c varsmethods:r classes:cs {: RESULT = new ListAST(new ClassAST(c, r.head, r.tail), cs); :}
  ;

varsmethods ::= LBLOCK vars:vs {: RESULT = vs; :}
  ;
vars ::= CLASSNAME:c IDNAME:i ENDSTMT vars:r {: RESULT = new Pair(new ListAST(new VarDeclAST(c, i), r.head), r.tail); :}
  | methods:m {: RESULT = new Pair(new ListAST<VarDeclAST>(), m); :}
  ;
methods ::= RBLOCK {: RESULT = new ListAST<FuncDeclAST>(); :}
  | CLASSNAME:c IDNAME:i params:ps block:b methods:m {: RESULT = new ListAST(new FuncDeclAST(c, i, ps, b), m); :}
  ;

params ::= LPAREN paramlist:ps RPAREN {: RESULT = ps; :}
  ;
paramlist ::= {: RESULT = new ListAST<VarDeclAST>(); :}
  | nonemptyparamlist:ps {: RESULT = ps; :}
  ;
nonemptyparamlist ::= CLASSNAME:t IDNAME:x restparamlist:ps {: RESULT = new ListAST(new VarDeclAST(t, x), ps); :}
  ;
restparamlist ::= {: RESULT = new ListAST<VarDeclAST>(); :}
 | COMMA nonemptyparamlist:ps {: RESULT = ps; :}
 ;

// method body handling
block ::= LBLOCK blockvars:bv RBLOCK {: RESULT = new BlockAST(bv.head, bv.tail); :};
blockvars ::= stmts:s {: RESULT = new Pair(new ListAST<VarDeclAST>(), s); :}
  |   CLASSNAME:c IDNAME:i ENDSTMT blockvars:r {: RESULT = new Pair(new ListAST(new VarDeclAST(c, i), r.head), r.tail); :}
  ;

stmts ::= RETURN ENDSTMT reststmts:ss {: RESULT = new ListAST(new ReturnStmtAST(), ss); :}
  | RETURN IDNAME:i ENDSTMT reststmts:ss {: RESULT = new ListAST(new ReturnStmtAST(i), ss); :}
  ;
reststmts ::= {: RESULT = new ListAST<StmtAST>(); :}
  | stmts:ss {: RESULT = ss; :}
  ;

/*
aexp ::= MINUS aexp:e                     {: RESULT = new BinOpAST("-", new ConstAST(0), e);    :}    %prec UMINUS
    | aexp:e1 PLUS aexp:e2             {: RESULT = new BinOpAST("+", e1, e2); :}
    | aexp:e1 MINUS aexp:e2            {: RESULT = new BinOpAST("-", e1, e2); :}
    | aexp:e1 TIMES aexp:e2            {: RESULT = new BinOpAST("*", e1, e2); :}
    | aexp:e1 DIV aexp:e2              {: RESULT = new BinOpAST("/", e1, e2); :}
    | intconst:e	                     {: RESULT = e;     :}
    | LPAREN aexp:e RPAREN             {: RESULT = e;     :}
    ;
    */

intconst ::= INTCONST:n {: RESULT = new ConstAST(n); :}
  ;
boolconst ::= BOOLCONST:b {: RESULT = new ConstAST(b); :}
  ;
stringliteral ::= STRING_LITERAL:s {: RESULT = new ConstAST(s); :}
  ;
