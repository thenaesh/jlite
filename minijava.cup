/* Minijava Grammar */

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

import java.io.*;

parser code {:
  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
  }
  public static void main(String[] args) throws Exception {
      // initialize the symbol factory
      ComplexSymbolFactory csf = new ComplexSymbolFactory();
      // create a buffering scanner wrapper
      ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(args[0])),csf));
      // start parsing
      Parser p = new Parser(lexer,csf);
      System.out.println(p.parse().value.toString());
  }
:};

// terminals
terminal CLASS, WHILE, READLN, PRINTLN, IF, ELSE, THIS, NEW, NULL;
terminal Integer INTCONST;
terminal Boolean BOOLCONST;
terminal String STRING_LITERAL;
terminal MAINFUNC;
terminal PLUS, MINUS, TIMES, DIV, UMINUS;
terminal LT, GT, GEQ, LEQ, EQ, NEQ;
terminal OR, AND;
terminal LPAREN, RPAREN, LBLOCK, RBLOCK;
terminal COMMA, DOT, ENDSTMT;
terminal String IDNAME, CLASSNAME;

// non-terminals
non terminal ProgramAST program;
non terminal ClassAST mainclass;
non terminal FuncDeclAST mainfunction;
non terminal ListAST<ClassAST> classes;
non terminal Pair<ListAST<VarDeclAST>, ListAST<FuncDeclAST>> varsmethods, vars, methods;
non terminal ListAST<VarDeclAST> params, paramlist, nonemptyparamlist, restparamlist;
non terminal AST block, stmts;
non terminal AST expr;
non terminal ConstAST<Integer> intconst;
non terminal ConstAST<Boolean> boolconst;
non terminal ConstAST<String> stringliteral;

// precedence
precedence left CLASS, IDNAME, CLASSNAME;
precedence left LPAREN, RPAREN;
precedence left PLUS, MINUS, TIMES, DIV;
precedence left UMINUS;

// program handling
program ::= mainclass:mc classes:cs {:  RESULT = new ProgramAST(mc, cs); :};

// main class handling
mainclass ::= CLASS CLASSNAME:c LBLOCK mainfunction:f RBLOCK {: RESULT = new ClassAST(c, new ListAST<VarDeclAST>(), new ListAST(f)); :} ;
mainfunction ::= MAINFUNC params:ps block {: RESULT = new FuncDeclAST("Void", "main", ps); :};

// general class handling
classes ::= {: RESULT = new ListAST<ClassAST>(); :}
  | CLASS CLASSNAME:c varsmethods:r classes:cs {: RESULT = new ListAST(new ClassAST(c, r.head, r.tail), cs); :}
  ;

varsmethods ::= LBLOCK vars:vs {: RESULT = vs; :}
  ;
vars ::= CLASSNAME:c IDNAME:i ENDSTMT vars:r {: RESULT = new Pair(new ListAST(new VarDeclAST(c, i), r.head), r.tail); :}
  | methods:r {: RESULT = new Pair(new ListAST<VarDeclAST>(), r.tail); :}
  ;
methods ::= RBLOCK {: RESULT = new Pair(new ListAST<VarDeclAST>(), new ListAST<FuncDeclAST>()); :}
  | CLASSNAME:c IDNAME:i params:ps block methods:r {: RESULT = new Pair(r.head, new ListAST(new FuncDeclAST(c, i, ps), r.tail)); :}
  ;

params ::= LPAREN paramlist:ps RPAREN {: RESULT = ps; :}
  ;
paramlist ::= {: RESULT = new ListAST<VarDeclAST>(); :}
  | nonemptyparamlist:ps {: RESULT = ps; :}
  ;
nonemptyparamlist ::= CLASSNAME:t IDNAME:x restparamlist:ps {: RESULT = new ListAST(new VarDeclAST(t, x), ps); :}
  ;
restparamlist ::= {: RESULT = new ListAST<VarDeclAST>(); :}
 | COMMA nonemptyparamlist:ps {: RESULT = ps; :}
 ;

// method body handling
block ::= LBLOCK stmts RBLOCK;
stmts ::= //empty
  ;

/*
program   ::=  expr:e     {: RESULT = new ProgramAST(e);  :}
    ;
*/


expr ::=
    | expr:e1 PLUS expr:e2             {: RESULT = new BinOpAST("+", e1, e2); :}
    | expr:e1 MINUS expr:e2            {: RESULT = new BinOpAST("-", e1, e2); :}
    | expr:e1 TIMES expr:e2            {: RESULT = new BinOpAST("*", e1, e2); :}
    | expr:e1 DIV expr:e2              {: RESULT = new BinOpAST("/", e1, e2); :}
    | intconst:e	                     {: RESULT = e;     :}
    | LPAREN expr:e RPAREN             {: RESULT = e;     :}
    | MINUS expr:e                     {: RESULT = new BinOpAST("-", new ConstAST(0), e);    :}    %prec UMINUS
    ;

intconst ::= INTCONST:n {: RESULT = new ConstAST(n); :}
  ;
boolconst ::= BOOLCONST:b {: RESULT = new ConstAST(b); :}
  ;
stringliteral ::= STRING_LITERAL:s {: RESULT = new ConstAST(s); :}
  ;
