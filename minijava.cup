/* Minijava Grammar */

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

import java.io.*;

parser code {:
  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
  }
  public static void main(String[] args) throws Exception {
      // initialize the symbol factory
      ComplexSymbolFactory csf = new ComplexSymbolFactory();
      // create a buffering scanner wrapper
      ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(args[0])),csf));
      // start parsing
      Parser p = new Parser(lexer,csf);
      System.out.println(p.parse().value.toString());
  }
:};

// terminals
terminal CLASS, WHILE, READLN, PRINTLN, IF, ELSE, THIS, NEW, NULL;
terminal Integer INTCONST;
terminal Boolean BOOLCONST;
terminal String STRING_LITERAL;
terminal MAINFUNC;
terminal PLUS, MINUS, TIMES, DIV, UMINUS;
terminal LT, GT, GEQ, LEQ, EQ, NEQ;
terminal OR, AND;
terminal LPAREN, RPAREN, LBLOCK, RBLOCK;
terminal ENDSTMT;
terminal String IDNAME, CLASSNAME;

// non-terminals
non terminal AST intconst, boolconst, stringliteral;
non terminal AST program, mainclass, expr;

// precedence
precedence left PLUS, MINUS, TIMES, DIV;
precedence left UMINUS;

/*
program ::= mainclass:r {:  RESULT = r :};

mainclass ::= CLASS STRING_LITERAL LBLOCK mainfunction:f RBLOCK {: RESULT = new AST("mainclass", null, f) :};
mainfunction ::= MAINFUNC LPAREN paramlist RPAREN LBLOCK RBLOCK {::};
*/

program   ::=  expr:e     {: RESULT = new AST("__program__", null, e);  :}
    ;


expr ::=
    | expr:e1 PLUS expr:e2             {: RESULT = new AST("plus", null, e1, e2); :}
    | expr:e1 MINUS expr:e2            {: RESULT = new AST("minus", null, e1, e2); :}
    | expr:e1 TIMES expr:e2            {: RESULT = new AST("times", null, e1, e2); :}
    | expr:e1 DIV expr:e2              {: RESULT = new AST("div", null, e1, e2); :}
    | intconst:e	                     {: RESULT = e;     :}
    | LPAREN expr:e RPAREN             {: RESULT = e;     :}
    | MINUS expr:e                     {: RESULT = new AST("uminus", null, e);    :}    %prec UMINUS
    ;

intconst ::= INTCONST:n {: RESULT = new AST("intconst", n); :}
  ;
boolconst ::= BOOLCONST:b {: RESULT = new AST("boolconst", b); :}
  ;
stringliteral ::= STRING_LITERAL:s {: RESULT = new AST("stringliteral", s); :}
  ;
